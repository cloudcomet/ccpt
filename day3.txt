Constructor in java

> Constructor is  a special member(inside class) function or method
> It is a special type of member function:
    ~ name of constructor is same as class name
    ~ no return type (not even void)
    ~

Constructor - Simple Explanation

> Constructor is a special method that runs when you create an object (new ClassName())
> Purpose: Initialize (set up) the object's data/fields when it is created
> Key points:
    ~ name must match the class name exactly
    ~ no return type (not even void)
    ~ can have parameters to pass initial values
    ~ automatically called when you use new keyword
> Example: class Car { String color; Car(String c) { color = c; } }  // Constructor with parameter
> If you don't write a constructor, Java provides a default no-argument constructor
> You can have multiple constructors (constructor overloading) with different parameter lists

Constructor - Detailed Explanation

> What is a Constructor?
    ~ A special method that initializes an object immediately after it is created using the new keyword
    ~ Runs automatically without explicit call
    ~ Used to set initial values to object variables and perform setup operations
    
> Constructor Syntax & Rules
    ~ Must have the same name as the class
    ~ No return type declaration (not even void)
    ~ Can be public, private, protected, or default (package-private)
    ~ Can have zero or more parameters
    ~ Syntax: [access-modifier] ClassName([parameters]) { constructor-body }
    ~ Example: public Car(String model, int year) { this.model = model; this.year = year; }

> Types of Constructors
    ~ Default Constructor: No-argument constructor provided by Java if you don't write any constructor
    ~ Parameterized Constructor: Takes one or more parameters to initialize object with values
    ~ Copy Constructor: Takes an object of the same class and copies its values

> Constructor Execution Flow
    1. When you write: Car myCar = new Car("Toyota", 2023);
    2. Memory is allocated for the new object
    3. Constructor matching the parameters is called automatically
    4. Constructor body executes (initializes fields, runs setup code)
    5. Reference to the new object is returned and stored in myCar

> Constructor Overloading
    ~ You can define multiple constructors with same name but different parameters
    ~ Helps provide flexibility in object creation
    ~ Example:
        public Car() { model = "Unknown"; year = 0; }                    // No-arg constructor
        public Car(String m) { model = m; year = 0; }                   // One parameter
        public Car(String m, int y) { model = m; year = y; }           // Two parameters

> this Keyword in Constructor
    ~ this.fieldName refers to instance variable (avoids confusion with local variables)
    ~ this() calls another constructor of the same class (constructor chaining)
    ~ Example: this.color = color;  // assigns parameter to instance variable

> Constructor Chaining (calling another constructor)
    ~ Use this(parameters) to call another constructor in the same class
    ~ Must be the first statement in the constructor
    ~ Reduces code duplication
    ~ Example:
        public Car(String m, int y) { this.model = m; this.year = y; }
        public Car(String m) { this(m, 0); }  // calls the two-parameter constructor

> Access Modifiers for Constructors
    ~ public: accessible from anywhere
    ~ private: accessible only within the class (prevents object creation from outside)
    ~ protected: accessible within the class and subclasses
    ~ default (no modifier): accessible only within the package

> Key Differences: Constructor vs Method
    ~ Constructor has no return type; methods have return type (can be void)
    ~ Constructor name must match class name; methods can have any name
    ~ Constructor called automatically; methods need explicit call
    ~ Constructor called once during object creation; methods called multiple times
    ~ Constructor initializes object; methods define object behavior

> Common Use Cases
    ~ Initializing object state (setting field values)
    ~ Performing validation on input parameters
    ~ Opening connections or resources
    ~ Setting up related objects
    ~ Logging object creation

For-Each Loop in Java

> Enhanced for loop (for-each) iterates over all elements of an array or Iterable without an index
> Syntax: for (ElementType element : collectionOrArray) { statement-or-block }
> Array example: int[] a = {1,2,3}; for (int x : a) System.out.println(x);
> Collection example: List<String> names = List.of("A","B"); for (String s : names) System.out.println(s);
> Features:
    ~ Loop variable does not expose index; use traditional for loop if index needed
    ~ Reassigning loop variable does not change underlying container
    ~ Can mutate object fields via reference (e.g., obj.setFoo(...))
    ~ Uses collection's iterator internally (fast for arrays and ArrayList)
    ~ Do not structurally modify collection while iterating (causes ConcurrentModificationException)
> Java-8 alternative: collection.forEach(e -> { ... }) or method references like collection.forEach(System.out::println)
> Best for: readable, safe iteration when only elements needed and container won't be modified

For-Each Loop - Detailed Explanation

> What is a For-Each Loop?
    ~ Also called enhanced for loop, introduced in Java 5
    ~ Simplifies iteration over arrays and collections
    ~ Automatically handles iterator or array index behind the scenes
    ~ Makes code more readable and less error-prone

> Syntax & Structure
    ~ for (DataType variable : collection) { statement-or-block }
    ~ DataType: type of elements in the collection/array
    ~ variable: loop variable that holds current element (scope limited to loop)
    ~ collection: array or any Iterable object (ArrayList, HashSet, LinkedList, etc.)
    ~ Example: for (String name : names) { System.out.println(name); }

> How It Works Internally
    ~ For arrays: for-each translates to index-based loop (i = 0; i < length; i++)
    ~ For collections: uses Iterator under the hood (hasNext() and next())
    ~ You don't see the index or iterator, they are managed automatically
    ~ Loop variable automatically gets assigned each element in sequence

> For-Each with Arrays
    ~ Works with any array type (primitives and objects)
    ~ Example with int array:
        int[] numbers = {10, 20, 30, 40};
        for (int num : numbers) { System.out.println(num); }
    ~ Example with String array:
        String[] fruits = {"Apple", "Banana", "Orange"};
        for (String fruit : fruits) { System.out.println(fruit); }
    ~ Example with object array:
        Person[] people = {new Person("John"), new Person("Jane")};
        for (Person p : people) { System.out.println(p.getName()); }

> For-Each with Collections
    ~ Works with any collection implementing Iterable interface
    ~ Common collections: ArrayList, LinkedList, HashSet, HashMap.keySet(), etc.
    ~ Example with ArrayList:
        ArrayList<Integer> list = new ArrayList<>();
        list.add(1); list.add(2); list.add(3);
        for (Integer value : list) { System.out.println(value); }
    ~ Example with HashSet:
        HashSet<String> set = new HashSet<>();
        set.add("A"); set.add("B");
        for (String item : set) { System.out.println(item); }

> Loop Variable & Scope
    ~ Loop variable exists only within the for-each loop block
    ~ After loop ends, loop variable cannot be accessed
    ~ Each iteration assigns the next element to the loop variable
    ~ Variable is final within the loop (you cannot reassign it to a different object)
    ~ Modifying loop variable does NOT affect the original collection

> Modifying Elements During Iteration
    ~ You can modify the object's internal state if it's mutable:
        class Person { String name; void setName(String n) { name = n; } }
        for (Person p : people) { p.setName("New Name"); }  // WORKS - modifies object
    ~ You CANNOT replace an element in the collection:
        for (String s : list) { s = "NewValue"; }  // Does NOT modify the list
    ~ Attempting to structurally modify (add/remove) collection throws ConcurrentModificationException

> Limitations & When Not to Use For-Each
    ~ No access to index: if you need the current position, use traditional for loop
    ~ Cannot iterate backwards: for-each always goes forward; use traditional for for backward iteration
    ~ Cannot remove elements: for-each doesn't support safe removal; use Iterator.remove()
    ~ Cannot iterate over multiple collections simultaneously: use separate traditional loops
    ~ Example needing index:
        for (int i = 0; i < list.size(); i++) { System.out.println(i + ": " + list.get(i)); }

> For-Each vs Traditional For Loop
    ~ For-Each: for (String s : names) { ... }
    ~ Traditional: for (int i = 0; i < names.length; i++) { String s = names[i]; ... }
    ~ For-Each is shorter, cleaner, and avoids index out of bounds errors
    ~ Use traditional when you need index or complex iteration logic

> For-Each vs forEach() Method (Java 8+)
    ~ For-Each loop: for (String s : list) { System.out.println(s); }
    ~ forEach() method: list.forEach(s -> System.out.println(s));
    ~ Both achieve same result, forEach() is more functional style
    ~ forEach() with method reference: list.forEach(System.out::println);
    ~ forEach() cannot use break/continue, for-each can

> Nested For-Each Loops
    ~ Use for iterating over multidimensional arrays or collections of collections
    ~ Example with 2D array:
        int[][] matrix = {{1,2,3}, {4,5,6}, {7,8,9}};
        for (int[] row : matrix) { for (int val : row) { System.out.println(val); } }
    ~ Example with list of lists:
        List<List<String>> matrix = new ArrayList<>();
        for (List<String> row : matrix) { for (String val : row) { System.out.println(val); } }

> Important Rules & Best Practices
    ~ Use for-each when you only need elements (not indices)
    ~ Use for-each for cleaner, more readable code
    ~ Avoid modifying collection structure during iteration (use Iterator.remove() if needed)
    ~ Use traditional for loop when you need index or backward iteration
    ~ Use forEach() for functional/stream-based code
    ~ For-each is generally faster than indexed access on LinkedList (avoids O(n) lookups)

> Common Mistakes
    ~ Trying to modify the collection: for (String s : list) { list.remove(s); }  // ConcurrentModificationException
    ~ Expecting index: for (String s : list) { /* no way to get current index */ }
    ~ Modifying loop variable expecting collection change: s = "new";  // doesn't change list
    ~ Using break incorrectly in nested loops: understand scope carefully 